\Stephan{\subsection{Übungsblatt 5}
	\begin{frame}{MIMA-Simulationen}
	    \begin{itemize}
	    	\item \url{github.com/WArBp-3R/kit-mima-sim}
	    	\item \url{github.com/C1bergh0st/MiMaSimlator}
	    	\item \url{github.com/cbdevnet/mima}
	    	\item \url{github.com/phiresky/mima}
	    	\item \url{ch-st.de/mima/?63.mima}
	    \end{itemize}
	
	
	\end{frame}

	    
\begin{frame}{Zum 5. Übungsblatt}
	\emph{Homomorphismen}
	\begin{itemize}
		\item Homomorphismen sind bei Wörtern immer als $h:A^{\ast} \to B^{\ast}$ definiert (mit $A,B$ Alphabete).
		\item Man kann einen Homorphismus definieren, indem man nur eine Funktion $g:A\to B^{\ast}$ angibt, die einzelne Zeichen abbildet. 
		\item \textbf{ABER:} Dann muss man den induzierten Homomorphismus $g^{\ast\ast}$ von $g$ als gesuchten Homomorphismus angeben!
		\item Beispiel (Aufg 5.3):

		\begin{align*}
			g_1&: \set{0,1}^\ast \to \set{0,1}^\ast, \; g_1(0)=1, \; g_1(0)=0 \\
			h_1& = g_{1}^{\ast\ast}
		\end{align*}
	\end{itemize}
\end{frame}
}

\Moritz{
	
\subsection{Übungsblatt 5}
\begin{frame}{Zum 5. Übungsblatt}
	\emph{Homomorphismen}
	\begin{itemize}
		\item Homomorphismen sind bei Wörtern immer als $h:A^{\ast} \to B^{\ast}$ definiert (mit $A,B$ Alphabete).
		\item Man kann einen Homorphismus definieren, indem man nur eine Funktion $g:A\to B^{\ast}$ angibt, die einzelne Zeichen abbildet. 
		\item \textbf{ABER:} Dann muss man den induzierten Homomorphismus $g^{\ast\ast}$ von $g$ als gesuchten Homomorphismus angeben!
		\item Beispiel (Aufg 5.3):

		\begin{align*}
			g_1&: \set{0,1}^\ast \to \set{0,1}^\ast, \; g_1(0)=1, \; g_1(0)=0 \\
			h_1& = g_{1}^{\ast\ast}
		\end{align*}
	\end{itemize}
\end{frame}

\subsection{Übungsblatt 6}
\begin{frame}{Zum 6. Übungsblatt}
	\emph{Die MIMA ist eine Maschine!}
	\begin{itemize}
		\item Die MIMA verhält sich anders, als die mathematischen Algorithmen, die sie versucht zu berechnen.
		\item Insbesondere gibt es \textbf{Overflows und Underflows}, so wie beim echten Computer auch.
		\item Die MIMA hat Werte mit 24 Bit Länge. 
		\item \textit{Annahme: An Adresse x steht } $Zkpl_{24}(-2^{23})$.
		\begin{algorithmic}[1]
			\State \texttt{LDC} $0$
			\State \texttt{NOT}
			\State \texttt{ADD} $x$
		\end{algorithmic}
		liefert $Akku = Zkpl_{24}(2^{23}-1)$
	\end{itemize}
\end{frame}

\begin{frame}{}
	\emph{EQL!!!}
	\begin{itemize}
		\item Verwendet den MIMA Befehl \texttt{EQL} als Sprungbedingung!
		\item \texttt{EQL} vereinfacht einem das Leben, indem es Gleichheit abfragen kann, ohne dass man rumrechnen muss.
		\item Zum Beispiel Abbruchbedingung der while-Schleife in Aufgabe 6.3, wenn man hochgezählt hat: \begin{algorithmic}[1]
			\State \texttt{LDC} 24
			\State \texttt{EQL} x \text{ (x: Name der Addresse in der Zählvariable gespeichert ist.)}
			\State \texttt{JMN} while
		\end{algorithmic}
	\end{itemize}

	\bigskip

	\begin{columns}
		\begin{column}{0.475\textwidth}
			MIMA:
			\begin{center}
				\begin{algorithmic}[1]
					\State \texttt{EQL} x
					\State \texttt{JMN} $a$
				\end{algorithmic}
			\end{center}
		\end{column}
		
		\begin{column}{0.475\textwidth}
			Pseudocode: \\[1em]
				\texttt{IF} ($Akku = M(x)$) \texttt{THEN} \\
				\quad Jump to $a$
		\end{column}
	\end{columns}
\end{frame}

}