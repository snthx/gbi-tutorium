\input{../modes.tex}

\input{../templates/praeambelTut.tex}

\title[Speicher und Minimalmaschine]{6. Tutorium\\ Speicher und Minimalmaschine}
\subtitle{Grundbegriffe der Informatik, Tutorium \#\mytutnumber}
\date{\today}

\begin{document}
\titleframe
\roadmap

%%%%%%%%%% %%%%%%%%%%
\section{Speicher}
\subsection{Funktionen von Funktionen}

\begin{frame}{Funktionsception: Funktionen von Funktionen}
	\begin{block}{Def.: $B^A$}
		Seien A und B Mengen. Mit $B^A$ bezeichnen wir die Menge aller Abbildungen von $A$ nach $B$, also $$B^A = \set{f \mid f : A \to B }$$
	\end{block}

	\begin{block}{Beobachtung}
		Für endliche Mengen $A$ und $B$ gilt:
		$$|B^A| = |B|^{|A|}$$
	\end{block}
\end{frame}

\begin{frame}{Funktionsception${}^2$: Funktionen als Argument von Funktionen}

	\begin{exampleblock}{Beispiel}
		\small Es sei $M$ eine Menge. Jede Teilmenge $L_i \subseteq M$ kann man bijektiv mit einer Abbildung $f_i \colon M \to \set{0,1}$, also einem $f_i \in \set{0,1}^M$ in Beziehung setzen.

		Dann kann man die Vereinigung $\bigcup$ als Abbildung darstellen:
		$$V\colon \{0,1\}^M \times \{0,1\}^M\to \{0,1\}^M$$
		\pause
		\begin{columns}
			\begin{column}{0.4\textwidth}
				Beispielbild für $L_1=\{a,c,d\}$ \\ und $L_2=\{b,c\}$
			\end{column}
			\begin{column}{0.4\textwidth}
				\begin{tabular}{*{4}{>{$}c<{$}}}
					& L_1 & L_2 & L_1\cup L_2 \\
					x & f_1(x) & f_2(x) & V(f_1,f_2) \\
					\hline
					a & 1 & 0 & 1 \\
					b & 0 & 1 & 1 \\
					c & 1 & 1 & 1 \\
					d & 1 & 0 & 1 \\
					e & 0 & 0 & 0 \\
				\end{tabular}
			\end{column}
			\end{columns}	
		\medskip
		\pause \centering Wie könnte nun eine Abbildungsvorschrift aussehen?
	\end{exampleblock}
\end{frame}
\begin{frame}{Funktionsception${}^2$: Funktionen als Argument von Funktionen}
	\begin{exampleblock}{Wie könnte eine Abbildungsvorschrift aussehen?}
	\begin{align*}
		V\colon \{0,1\}^M \times \{0,1\}^M &\to \{0,1\}^M \\
		(f_1,f_2) &\mapsto (x \mapsto \max(f_1(x),f_2(x))) \\[2ex]
		\text{äquivalent }  V(f_1,f_2) (x) &= \max(f_1(x),f_2(x)) \\
	\end{align*}
	\end{exampleblock}
\end{frame}

\subsection{Speicher}

\begin{frame}{Bits und Bytes}
	\begin{block}{Def.: Bit und Byte}
		Eine \textbf{Bit} ist ein Zeichen des Alphabets $\set{0,1}$ \\
		Ein Wort aus 8 Bits wird \textbf{Byte} genannt. 
	\end{block}
\end{frame}
\begin{frame}{Speicher}
	\begin{block}{Speicher}
		Ein \textbf{Speicher} $m$ bildet Adressen ($Adr$) auf Werte ($Val$) ab.\\
		Also $m \in Val^{Adr}$ bzw. $m \colon Adr \to Val$.
	\end{block}

	\begin{exampleblock}{Dazu sei einiges gesagt:}
		\begin{itemize}
			\item Statt ``Speicher'' trifft es \textbf{aktueller Zustand des Speichers} besser.
			\item Vorstellung als Tabelle. Linke Spalte Adressen, rechte Spalte Werte.
			\item (Noch) interessiert nicht die konkrete Realisierung, sondern nur die abstrakte Funktionsweise.
			\item Im Umgang mit Speicher benutzen wir hier nur Zahlen im Binärsystem, d.h.
				$$Adr = 2^k, Val = 2^l \quad k,l \in \nN_+$$
				Bei der \emph{MIMA}: $k=20, l=24$.
		\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}{Speicher - Methoden}
	\begin{block}{Def.: $memread$}
		Gibt im aktuellen Speicherzustand $m$ den Wert an der Adresse $a$ zurück.
		\begin{align*}
			memread : Val^{Adr} \times Adr &\to Val \\
									(m,a) &\mapsto m(a)
	\end{align*}
	\end{block}
% \end{frame}

% \begin{frame}{Speicher - Methoden}
	\begin{block}{Def.: $memwrite$}
		Speichert einen Wert $v$ in die Adresse $a$.
		\begin{align*}
			memwrite : Val^{Adr} \times Adr \times Val &\to Val^{Adr} \\
			(m,a,v) &\mapsto m'
		\end{align*}
		$m'$ ist nun ein neuer Speicherzustand, für den gilt:
		\begin{equation*}
			m'(a') =
				\begin{cases}
					v & \text{, falls } a'=a \\
					m(a') & \text{, sonst}
				\end{cases}
		\end{equation*}
		%\phantom{Moritz ist ein kek}\\
		Das Resultat ist eine neue Abbildung, bei der ich nur der Funktionswert an $a$ geändert hat.			
	\end{block}
\end{frame}

% \begin{frame}{Speicher}
% 	\begin{block}{Beispiel}
		
% 	$memread(m, 01) = \only<2->{00000111}$\\
% 	\visible<2-|handout:2>{$memwrite(m, 01, 11111100)$\\}
% 	\visible<4-|handout:2>{$memread(memwrite(m, 01, 11111100), 01) = 11111100$\\}
% 	\bigskip
	
% 	\begin{table}
% 		\begin{tabular}{|c|c|}
% 			\hline
% 			\multicolumn{2}{|c|}{Speicher $m$} \\
% 			\hline
% 			00 & 00101000 \\
% 			\only<-2|handout:1>{01 & 00000111}\only<3-|handout:2>{\color{blue} 01 & \color{blue} 11111100}  \\
% 			10 & 10010110 \\
% 			11 & 00100101 \\
% 			\hline
% 		\end{tabular} \par
% 		\bigskip
% 		Zustand bei \only<-2|handout:1>{$t=0$}\only<3-|handout:2>{\color{blue}$t=1$}
% 	\end{table}

% 	\end{block}
% \end{frame}

\begin{frame}{Speicher - Methoden}
	\begin{exampleblock}{Aufgabe}
		Gib an: \\
		\begin{itemize}
			\item $memread(memwrite(m,a,v),a)$
			\item $memread(memwrite(memwrite(m,a,v)a',v'),a)$
			\item $memread(memwrite(memwrite(m,a,v)a,v')a)$
		\end{itemize}
	\end{exampleblock}
	\pause
	\begin{block}{Lösung}
	\small
		\begin{itemize}
			\item $memread(memwrite(m,a,v),a) = v$
			\item $memread(memwrite(memwrite(m,a,v)a',v'),a) = \begin{cases}
																	v' & \text{, falls } a = a' \\
																	v  & \text{, falls } a \neq a' \\
																\end{cases}$
			\item $memread(memwrite(memwrite(m,a,v)a,v')a) = v' $
		\end{itemize}
	\end{block}
\end{frame}

\section[MIMA]{Minimalmaschine}
\begin{frame}{Minimalmaschine - ein idealisierter Prozessor}
	\only<1|handout:1>{\includegraphics[width=\linewidth]{MIMA_simple.png}} \only<2|handout:2>{\includegraphics[width=\linewidth]{MIMA.png}}
\end{frame}

\begin{frame}{Minimalmaschine: Befehle}\small
\begin{columns}
	\begin{column}{0.6\textwidth}
		\begin{tabular}{|l|l|}
			\toprule
				% Zugriffsoperationen
				LDC $c$ & $c \rightarrow Akku$ \\
				LDV $c$ & $M(a) \rightarrow Akku$ \\
				STV $c$ & $M(a) \leftarrow Akku$ \\
				LDIV $a$ & $M(M(a)) \rightarrow Akku$ \\
				STIV $a$ &$M(M(a)) \leftarrow Akku$ \\
				\midrule
				% Rechenoperationen
				ADD $a$ & $Akku + M(a) \rightarrow Akku$ \\
				AND $a$ & $Akku \ AND \ M(a) \rightarrow Akku$ \\
				OR $a$ & $Akku \ OR \ M(a) \rightarrow Akku$\\
				XOR $a$ & $Akku \ XOR \ M(a) \rightarrow Akku$\\
				NOT & Einskomplement von $Akku \rightarrow Akku$\\
				RAR & rotiert $Akku$ um 1 nach rechts $\rightarrow Akku$\\
				\midrule
				% Vergleichsoperationen
				EQL $a$ & $Akku \leftarrow \begin{cases}
											-1 & \text{, falls } Akku = M(a) \\
											0 & \text{, sonst} 
											\end{cases}$\\
				\midrule
				% Sprünge
				JMP $a$ & fahre fort mit Befehl an der Adresse $a$\\
				JMN $a$ & falls $Akku < 0$: JMP $a$\\
				HALT & stoppt die Mima\\
			\bottomrule	
		\end{tabular}
	\end{column}

	\begin{column}{0.32\textwidth}
		$c$: Konstante \\
		$a$: Adresse \\
		$M(a)$: Wert an Adresse $a$
	\end{column}
\end{columns}
\end{frame}

\begin{frame}{Minimalmaschine}
	\begin{exampleblock}{Eigenschaften}
		\begin{itemize}
		\item Adressen sind 20 Bit lang
		\item Werte sind 24 Bit lang
		\item Befehlscodierungen:
		\begin{itemize}
			\item 4 Bit für den OpCode und 20 Bit für einen Parameter (Adresse / Konstante)
			\item 8 Bit Befehl (Rest irrelevant)\\
			\includegraphics[width=100px]{MIMA_commands.png}\\
		\end{itemize} 
	\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}{Minimalmaschine}
	\begin{alertblock}{HALT}
		Jedes Programm muss mit HALT enden! Sonst läuft das Programm endlos weiter!
	\end{alertblock}

	\begin{alertblock}{Negative Konstanten}
		Negative Konstanten können nicht mit LDC geladen werden.\\
		Warum? \pause Unser Akku ist 24 Bit breit, aber wir können nur in die hinteren 20 Bit laden!
	\end{alertblock}
\end{frame}

\subsection{Aufgaben}
\begin{frame}{Minimalmaschine}
	\begin{exampleblock}{Aufgabe}
		Schreibe ein Programm, das von einer an Adresse $a_1$ gegebenen positiven Zahl das Zweierkomplement berechnet und in Adresse $a_2$ speichert.
	\end{exampleblock}
	\pause
	\begin{block}{Lösung}
			LDV $a_1$\\
			NOT\\
			STV $a_2$\\
			LDC 1\\
			ADD $a_2$\\
			STV $a_2$
		\end{block}
\end{frame}

\begin{frame}{}
	\begin{exampleblock}{Aufgabe}
		Seien $0 < b \leq a$ mit  $a,b \in \nN_+$. Schreibe ein Programm, das $a-b$ berechnet und das Ergebnis in $a$ speichert.
	\end{exampleblock}

	% \begin{block}{Lösung}
	% 	% TODO
	% \end{block}
\end{frame}

\begin{frame}{Minimalmaschine}
	\begin{exampleblock}{Aufgabe}
		Schreibe ein Programm, das eine an Speicheradresse $a_1$ gegebenen Zahl Modulo R rechnet und an Adresse $a_2$ ablegt.
	\begin{itemize}
		\item Modulo 2
		\item Modulo 3
	\end{itemize}
	\end{exampleblock}
\end{frame}

\begin{frame}{Minimalmaschine}
	\begin{block}{Lösung: Modulo 2}
		start:   LDC 1 //000000000000000000000001 \\
		$\qquad$ AND $a_1$ \\
		$\qquad$ STV $a_1$ \\
		$\qquad$ HALT
	\end{block}
\end{frame}

\begin{frame}{Minimalmaschine}
	\begin{block}{Lösung: Modulo 3}\small
		start:   LDC 1 \\
		$\qquad$ STV One\\
		$\qquad$ LDC 3\\
		$\qquad$ NOT\\
		$\qquad$ ADD One\\
		$\qquad$ STV MThree\\
		\medskip
		while:   LDV MThree\\
		$\qquad$ ADD $a_1$\\
		$\qquad$ JMN abschluss\\
		$\qquad$ STV $a_1$\\
		$\qquad$ JMP while\\
		\medskip
		ende:    LDC 3\\
		$\qquad$ ADD $a_1$\\
		$\qquad$ HALT\\
	\end{block}
\end{frame}

\begin{frame}{Minimalmaschine}
	\begin{exampleblock}{Aufgabe (Fibonacci-Folge)}
		Für $n \in \nN_0$ sei $\mathcal{F}(n)$ rekursiv definiert durch\\
		\begin{align*}
			 \mathcal{F}(0) &=  \mathcal{F}(1) = 1\\
			\text{für alle }n>1: \mathcal{F}(n) &= \mathcal{F}(n-1) + \mathcal{F}(n-2)\\
		\end{align*}
		Schreibe ein Maschinenprogramm, dass $\mathcal{F}(n)$ für ein gegebenes $n \in \nN_0$ berechnet.
	\end{exampleblock}

	% \begin{block}{Lösung}
	% 	% TODO
	% \end{block}
\end{frame}

%%%%%%%%%% %%%%%%%%%%
\section{}
\questionframe
\lastframe
\mode<handout>{\slideThanks}
\end{document}